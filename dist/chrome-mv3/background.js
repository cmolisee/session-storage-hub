var background=function(){"use strict";function se(e){return e==null||typeof e=="function"?{main:e}:e}const ne=[EvalError,RangeError,ReferenceError,SyntaxError,TypeError,URIError,globalThis.DOMException,globalThis.AssertionError,globalThis.SystemError].filter(Boolean).map(e=>[e.name,e]),ae=new Map(ne);class q extends Error{name="NonError";constructor(r){super(q._prepareSuperMessage(r))}static _prepareSuperMessage(r){try{return JSON.stringify(r)}catch{return String(r)}}}const ie=[{property:"name",enumerable:!1},{property:"message",enumerable:!1},{property:"stack",enumerable:!1},{property:"code",enumerable:!0},{property:"cause",enumerable:!1}],L=new WeakSet,oe=e=>{L.add(e);const r=e.toJSON();return L.delete(e),r},J=e=>ae.get(e)??Error,D=({from:e,seen:r,to:t,forceEnumerable:a,maxDepth:y,depth:u,useToJSON:d,serialize:v})=>{if(!t)if(Array.isArray(e))t=[];else if(!v&&Y(e)){const A=J(e.name);t=new A}else t={};if(r.push(e),u>=y)return t;if(d&&typeof e.toJSON=="function"&&!L.has(e))return oe(e);const E=A=>D({from:A,seen:[...r],forceEnumerable:a,maxDepth:y,depth:u,useToJSON:d,serialize:v});for(const[A,f]of Object.entries(e)){if(f&&f instanceof Uint8Array&&f.constructor.name==="Buffer"){t[A]="[object Buffer]";continue}if(f!==null&&typeof f=="object"&&typeof f.pipe=="function"){t[A]="[object Stream]";continue}if(typeof f!="function"){if(!f||typeof f!="object"){try{t[A]=f}catch{}continue}if(!r.includes(e[A])){u++,t[A]=E(e[A]);continue}t[A]="[Circular]"}}for(const{property:A,enumerable:f}of ie)typeof e[A]<"u"&&e[A]!==null&&Object.defineProperty(t,A,{value:Y(e[A])?E(e[A]):e[A],enumerable:a?!0:f,configurable:!0,writable:!0});return t};function le(e,r={}){const{maxDepth:t=Number.POSITIVE_INFINITY,useToJSON:a=!0}=r;return typeof e=="object"&&e!==null?D({from:e,seen:[],forceEnumerable:!0,maxDepth:t,depth:0,useToJSON:a,serialize:!0}):typeof e=="function"?`[Function: ${e.name||"anonymous"}]`:e}function ce(e,r={}){const{maxDepth:t=Number.POSITIVE_INFINITY}=r;if(e instanceof Error)return e;if(ge(e)){const a=J(e.name);return D({from:e,seen:[],to:new a,maxDepth:t,depth:0,serialize:!1})}return new q(e)}function Y(e){return!!e&&typeof e=="object"&&"name"in e&&"message"in e&&"stack"in e}function ge(e){return!!e&&typeof e=="object"&&"message"in e&&!Array.isArray(e)}var ue=Object.defineProperty,me=Object.defineProperties,de=Object.getOwnPropertyDescriptors,Z=Object.getOwnPropertySymbols,Ae=Object.prototype.hasOwnProperty,fe=Object.prototype.propertyIsEnumerable,Q=(e,r,t)=>r in e?ue(e,r,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[r]=t,H=(e,r)=>{for(var t in r||(r={}))Ae.call(r,t)&&Q(e,t,r[t]);if(Z)for(var t of Z(r))fe.call(r,t)&&Q(e,t,r[t]);return e},X=(e,r)=>me(e,de(r)),he=(e,r,t)=>new Promise((a,y)=>{var u=E=>{try{v(t.next(E))}catch(A){y(A)}},d=E=>{try{v(t.throw(E))}catch(A){y(A)}},v=E=>E.done?a(E.value):Promise.resolve(E.value).then(u,d);v((t=t.apply(e,r)).next())});function we(e){let r,t={};function a(){Object.entries(t).length===0&&(r?.(),r=void 0)}let y=Math.floor(Math.random()*1e4);function u(){return y++}return{sendMessage(d,v,...E){return he(this,null,function*(){var A,f,b,S;const O={id:u(),type:d,data:v,timestamp:Date.now()},P=(f=yield(A=e.verifyMessageData)==null?void 0:A.call(e,O))!=null?f:O;(b=e.logger)==null||b.debug(`[messaging] sendMessage {id=${P.id}} ─ᐅ`,P,...E);const i=yield e.sendMessage(P,...E),{res:n,err:s}=i??{err:new Error("No response")};if((S=e.logger)==null||S.debug(`[messaging] sendMessage {id=${P.id}} ᐊ─`,{res:n,err:s}),s!=null)throw ce(s);return n})},onMessage(d,v){var E,A,f;if(r==null&&((E=e.logger)==null||E.debug(`[messaging] "${d}" initialized the message listener for this context`),r=e.addRootListener(b=>{var S,O;if(typeof b.type!="string"||typeof b.timestamp!="number"){if(e.breakError)return;const n=Error(`[messaging] Unknown message format, must include the 'type' & 'timestamp' fields, received: ${JSON.stringify(b)}`);throw(S=e.logger)==null||S.error(n),n}(O=e?.logger)==null||O.debug("[messaging] Received message",b);const P=t[b.type];if(P==null)return;const i=P(b);return Promise.resolve(i).then(n=>{var s,o;return(o=(s=e.verifyMessageData)==null?void 0:s.call(e,n))!=null?o:n}).then(n=>{var s;return(s=e?.logger)==null||s.debug(`[messaging] onMessage {id=${b.id}} ─ᐅ`,{res:n}),{res:n}}).catch(n=>{var s;return(s=e?.logger)==null||s.debug(`[messaging] onMessage {id=${b.id}} ─ᐅ`,{err:n}),{err:le(n)}})})),t[d]!=null){const b=Error(`[messaging] In this JS context, only one listener can be setup for ${d}`);throw(A=e.logger)==null||A.error(b),b}return t[d]=v,(f=e.logger)==null||f.log(`[messaging] Added listener for ${d}`),()=>{delete t[d],a()}},removeAllListeners(){Object.keys(t).forEach(d=>{delete t[d]}),a()}}}var xe=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function pe(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var ee={exports:{}};(function(e,r){(function(t,a){a(e)})(typeof globalThis<"u"?globalThis:typeof self<"u"?self:xe,function(t){if(!globalThis.chrome?.runtime?.id)throw new Error("This script should only be loaded in a browser extension.");if(typeof globalThis.browser>"u"||Object.getPrototypeOf(globalThis.browser)!==Object.prototype){const a="The message port closed before a response was received.",y=u=>{const d={alarms:{clear:{minArgs:0,maxArgs:1},clearAll:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getAll:{minArgs:0,maxArgs:0}},bookmarks:{create:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},getChildren:{minArgs:1,maxArgs:1},getRecent:{minArgs:1,maxArgs:1},getSubTree:{minArgs:1,maxArgs:1},getTree:{minArgs:0,maxArgs:0},move:{minArgs:2,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeTree:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}},browserAction:{disable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},enable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},getBadgeBackgroundColor:{minArgs:1,maxArgs:1},getBadgeText:{minArgs:1,maxArgs:1},getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},openPopup:{minArgs:0,maxArgs:0},setBadgeBackgroundColor:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setBadgeText:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},browsingData:{remove:{minArgs:2,maxArgs:2},removeCache:{minArgs:1,maxArgs:1},removeCookies:{minArgs:1,maxArgs:1},removeDownloads:{minArgs:1,maxArgs:1},removeFormData:{minArgs:1,maxArgs:1},removeHistory:{minArgs:1,maxArgs:1},removeLocalStorage:{minArgs:1,maxArgs:1},removePasswords:{minArgs:1,maxArgs:1},removePluginData:{minArgs:1,maxArgs:1},settings:{minArgs:0,maxArgs:0}},commands:{getAll:{minArgs:0,maxArgs:0}},contextMenus:{remove:{minArgs:1,maxArgs:1},removeAll:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},cookies:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:1,maxArgs:1},getAllCookieStores:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},devtools:{inspectedWindow:{eval:{minArgs:1,maxArgs:2,singleCallbackArg:!1}},panels:{create:{minArgs:3,maxArgs:3,singleCallbackArg:!0},elements:{createSidebarPane:{minArgs:1,maxArgs:1}}}},downloads:{cancel:{minArgs:1,maxArgs:1},download:{minArgs:1,maxArgs:1},erase:{minArgs:1,maxArgs:1},getFileIcon:{minArgs:1,maxArgs:2},open:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},pause:{minArgs:1,maxArgs:1},removeFile:{minArgs:1,maxArgs:1},resume:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},extension:{isAllowedFileSchemeAccess:{minArgs:0,maxArgs:0},isAllowedIncognitoAccess:{minArgs:0,maxArgs:0}},history:{addUrl:{minArgs:1,maxArgs:1},deleteAll:{minArgs:0,maxArgs:0},deleteRange:{minArgs:1,maxArgs:1},deleteUrl:{minArgs:1,maxArgs:1},getVisits:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1}},i18n:{detectLanguage:{minArgs:1,maxArgs:1},getAcceptLanguages:{minArgs:0,maxArgs:0}},identity:{launchWebAuthFlow:{minArgs:1,maxArgs:1}},idle:{queryState:{minArgs:1,maxArgs:1}},management:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},getSelf:{minArgs:0,maxArgs:0},setEnabled:{minArgs:2,maxArgs:2},uninstallSelf:{minArgs:0,maxArgs:1}},notifications:{clear:{minArgs:1,maxArgs:1},create:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:0},getPermissionLevel:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},pageAction:{getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},hide:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},permissions:{contains:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},request:{minArgs:1,maxArgs:1}},runtime:{getBackgroundPage:{minArgs:0,maxArgs:0},getPlatformInfo:{minArgs:0,maxArgs:0},openOptionsPage:{minArgs:0,maxArgs:0},requestUpdateCheck:{minArgs:0,maxArgs:0},sendMessage:{minArgs:1,maxArgs:3},sendNativeMessage:{minArgs:2,maxArgs:2},setUninstallURL:{minArgs:1,maxArgs:1}},sessions:{getDevices:{minArgs:0,maxArgs:1},getRecentlyClosed:{minArgs:0,maxArgs:1},restore:{minArgs:0,maxArgs:1}},storage:{local:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},managed:{get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1}},sync:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}}},tabs:{captureVisibleTab:{minArgs:0,maxArgs:2},create:{minArgs:1,maxArgs:1},detectLanguage:{minArgs:0,maxArgs:1},discard:{minArgs:0,maxArgs:1},duplicate:{minArgs:1,maxArgs:1},executeScript:{minArgs:1,maxArgs:2},get:{minArgs:1,maxArgs:1},getCurrent:{minArgs:0,maxArgs:0},getZoom:{minArgs:0,maxArgs:1},getZoomSettings:{minArgs:0,maxArgs:1},goBack:{minArgs:0,maxArgs:1},goForward:{minArgs:0,maxArgs:1},highlight:{minArgs:1,maxArgs:1},insertCSS:{minArgs:1,maxArgs:2},move:{minArgs:2,maxArgs:2},query:{minArgs:1,maxArgs:1},reload:{minArgs:0,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeCSS:{minArgs:1,maxArgs:2},sendMessage:{minArgs:2,maxArgs:3},setZoom:{minArgs:1,maxArgs:2},setZoomSettings:{minArgs:1,maxArgs:2},update:{minArgs:1,maxArgs:2}},topSites:{get:{minArgs:0,maxArgs:0}},webNavigation:{getAllFrames:{minArgs:1,maxArgs:1},getFrame:{minArgs:1,maxArgs:1}},webRequest:{handlerBehaviorChanged:{minArgs:0,maxArgs:0}},windows:{create:{minArgs:0,maxArgs:1},get:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:1},getCurrent:{minArgs:0,maxArgs:1},getLastFocused:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}}};if(Object.keys(d).length===0)throw new Error("api-metadata.json has not been included in browser-polyfill");class v extends WeakMap{constructor(c,m=void 0){super(m),this.createItem=c}get(c){return this.has(c)||this.set(c,this.createItem(c)),super.get(c)}}const E=l=>l&&typeof l=="object"&&typeof l.then=="function",A=(l,c)=>(...m)=>{u.runtime.lastError?l.reject(new Error(u.runtime.lastError.message)):c.singleCallbackArg||m.length<=1&&c.singleCallbackArg!==!1?l.resolve(m[0]):l.resolve(m)},f=l=>l==1?"argument":"arguments",b=(l,c)=>function(w,...x){if(x.length<c.minArgs)throw new Error(`Expected at least ${c.minArgs} ${f(c.minArgs)} for ${l}(), got ${x.length}`);if(x.length>c.maxArgs)throw new Error(`Expected at most ${c.maxArgs} ${f(c.maxArgs)} for ${l}(), got ${x.length}`);return new Promise((M,I)=>{if(c.fallbackToNoCallback)try{w[l](...x,A({resolve:M,reject:I},c))}catch(h){console.warn(`${l} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `,h),w[l](...x),c.fallbackToNoCallback=!1,c.noCallback=!0,M()}else c.noCallback?(w[l](...x),M()):w[l](...x,A({resolve:M,reject:I},c))})},S=(l,c,m)=>new Proxy(c,{apply(w,x,M){return m.call(x,l,...M)}});let O=Function.call.bind(Object.prototype.hasOwnProperty);const P=(l,c={},m={})=>{let w=Object.create(null),x={has(I,h){return h in l||h in w},get(I,h,T){if(h in w)return w[h];if(!(h in l))return;let k=l[h];if(typeof k=="function")if(typeof c[h]=="function")k=S(l,l[h],c[h]);else if(O(m,h)){let C=b(h,m[h]);k=S(l,l[h],C)}else k=k.bind(l);else if(typeof k=="object"&&k!==null&&(O(c,h)||O(m,h)))k=P(k,c[h],m[h]);else if(O(m,"*"))k=P(k,c[h],m["*"]);else return Object.defineProperty(w,h,{configurable:!0,enumerable:!0,get(){return l[h]},set(C){l[h]=C}}),k;return w[h]=k,k},set(I,h,T,k){return h in w?w[h]=T:l[h]=T,!0},defineProperty(I,h,T){return Reflect.defineProperty(w,h,T)},deleteProperty(I,h){return Reflect.deleteProperty(w,h)}},M=Object.create(l);return new Proxy(M,x)},i=l=>({addListener(c,m,...w){c.addListener(l.get(m),...w)},hasListener(c,m){return c.hasListener(l.get(m))},removeListener(c,m){c.removeListener(l.get(m))}}),n=new v(l=>typeof l!="function"?l:function(m){const w=P(m,{},{getContent:{minArgs:0,maxArgs:0}});l(w)}),s=new v(l=>typeof l!="function"?l:function(m,w,x){let M=!1,I,h=new Promise(j=>{I=function($){M=!0,j($)}}),T;try{T=l(m,w,I)}catch(j){T=Promise.reject(j)}const k=T!==!0&&E(T);if(T!==!0&&!k&&!M)return!1;const C=j=>{j.then($=>{x($)},$=>{let z;$&&($ instanceof Error||typeof $.message=="string")?z=$.message:z="An unexpected error occurred",x({__mozWebExtensionPolyfillReject__:!0,message:z})}).catch($=>{console.error("Failed to send onMessage rejected reply",$)})};return C(k?T:h),!0}),o=({reject:l,resolve:c},m)=>{u.runtime.lastError?u.runtime.lastError.message===a?c():l(new Error(u.runtime.lastError.message)):m&&m.__mozWebExtensionPolyfillReject__?l(new Error(m.message)):c(m)},g=(l,c,m,...w)=>{if(w.length<c.minArgs)throw new Error(`Expected at least ${c.minArgs} ${f(c.minArgs)} for ${l}(), got ${w.length}`);if(w.length>c.maxArgs)throw new Error(`Expected at most ${c.maxArgs} ${f(c.maxArgs)} for ${l}(), got ${w.length}`);return new Promise((x,M)=>{const I=o.bind(null,{resolve:x,reject:M});w.push(I),m.sendMessage(...w)})},p={devtools:{network:{onRequestFinished:i(n)}},runtime:{onMessage:i(s),onMessageExternal:i(s),sendMessage:g.bind(null,"sendMessage",{minArgs:1,maxArgs:3})},tabs:{sendMessage:g.bind(null,"sendMessage",{minArgs:2,maxArgs:3})}},_={clear:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}};return d.privacy={network:{"*":_},services:{"*":_},websites:{"*":_}},P(u,p,d)};t.exports=y(chrome)}else t.exports=globalThis.browser})})(ee);var ye=ee.exports;const N=pe(ye);function ve(e){return we(X(H({},e),{sendMessage(r,t){return t==null?N.runtime.sendMessage(r):N.tabs.sendMessage(t,r)},addRootListener(r){const t=(a,y)=>r(typeof a=="object"?X(H({},a),{sender:y}):a);return N.runtime.onMessage.addListener(t),()=>N.runtime.onMessage.removeListener(t)}}))}const V=ve(),be=globalThis.browser?.runtime?.id==null?globalThis.chrome:globalThis.browser;var re=Object.prototype.hasOwnProperty;function W(e,r){var t,a;if(e===r)return!0;if(e&&r&&(t=e.constructor)===r.constructor){if(t===Date)return e.getTime()===r.getTime();if(t===RegExp)return e.toString()===r.toString();if(t===Array){if((a=e.length)===r.length)for(;a--&&W(e[a],r[a]););return a===-1}if(!t||typeof e=="object"){a=0;for(t in e)if(re.call(e,t)&&++a&&!re.call(r,t)||!(t in r)||!W(e[t],r[t]))return!1;return Object.keys(r).length===a}}return e!==e&&r!==r}const _e=new Error("request for lock canceled");var Ee=function(e,r,t,a){function y(u){return u instanceof t?u:new t(function(d){d(u)})}return new(t||(t=Promise))(function(u,d){function v(f){try{A(a.next(f))}catch(b){d(b)}}function E(f){try{A(a.throw(f))}catch(b){d(b)}}function A(f){f.done?u(f.value):y(f.value).then(v,E)}A((a=a.apply(e,r||[])).next())})};class ke{constructor(r,t=_e){this._value=r,this._cancelError=t,this._queue=[],this._weightedWaiters=[]}acquire(r=1,t=0){if(r<=0)throw new Error(`invalid weight ${r}: must be positive`);return new Promise((a,y)=>{const u={resolve:a,reject:y,weight:r,priority:t},d=te(this._queue,v=>t<=v.priority);d===-1&&r<=this._value?this._dispatchItem(u):this._queue.splice(d+1,0,u)})}runExclusive(r){return Ee(this,arguments,void 0,function*(t,a=1,y=0){const[u,d]=yield this.acquire(a,y);try{return yield t(u)}finally{d()}})}waitForUnlock(r=1,t=0){if(r<=0)throw new Error(`invalid weight ${r}: must be positive`);return this._couldLockImmediately(r,t)?Promise.resolve():new Promise(a=>{this._weightedWaiters[r-1]||(this._weightedWaiters[r-1]=[]),Me(this._weightedWaiters[r-1],{resolve:a,priority:t})})}isLocked(){return this._value<=0}getValue(){return this._value}setValue(r){this._value=r,this._dispatchQueue()}release(r=1){if(r<=0)throw new Error(`invalid weight ${r}: must be positive`);this._value+=r,this._dispatchQueue()}cancel(){this._queue.forEach(r=>r.reject(this._cancelError)),this._queue=[]}_dispatchQueue(){for(this._drainUnlockWaiters();this._queue.length>0&&this._queue[0].weight<=this._value;)this._dispatchItem(this._queue.shift()),this._drainUnlockWaiters()}_dispatchItem(r){const t=this._value;this._value-=r.weight,r.resolve([t,this._newReleaser(r.weight)])}_newReleaser(r){let t=!1;return()=>{t||(t=!0,this.release(r))}}_drainUnlockWaiters(){if(this._queue.length===0)for(let r=this._value;r>0;r--){const t=this._weightedWaiters[r-1];t&&(t.forEach(a=>a.resolve()),this._weightedWaiters[r-1]=[])}else{const r=this._queue[0].priority;for(let t=this._value;t>0;t--){const a=this._weightedWaiters[t-1];if(!a)continue;const y=a.findIndex(u=>u.priority<=r);(y===-1?a:a.splice(0,y)).forEach(u=>u.resolve())}}}_couldLockImmediately(r,t){return(this._queue.length===0||this._queue[0].priority<t)&&r<=this._value}}function Me(e,r){const t=te(e,a=>r.priority<=a.priority);e.splice(t+1,0,r)}function te(e,r){for(let t=e.length-1;t>=0;t--)if(r(e[t]))return t;return-1}var Ie=function(e,r,t,a){function y(u){return u instanceof t?u:new t(function(d){d(u)})}return new(t||(t=Promise))(function(u,d){function v(f){try{A(a.next(f))}catch(b){d(b)}}function E(f){try{A(a.throw(f))}catch(b){d(b)}}function A(f){f.done?u(f.value):y(f.value).then(v,E)}A((a=a.apply(e,r||[])).next())})};class Te{constructor(r){this._semaphore=new ke(1,r)}acquire(){return Ie(this,arguments,void 0,function*(r=0){const[,t]=yield this._semaphore.acquire(1,r);return t})}runExclusive(r,t=0){return this._semaphore.runExclusive(()=>r(),1,t)}isLocked(){return this._semaphore.isLocked()}waitForUnlock(r=0){return this._semaphore.waitForUnlock(1,r)}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}}const R=globalThis.browser?.runtime?.id==null?globalThis.chrome:globalThis.browser,U=Oe();function Oe(){const e={local:K("local"),session:K("session"),sync:K("sync"),managed:K("managed")},r=i=>{const n=e[i];if(n==null){const s=Object.keys(e).join(", ");throw Error(`Invalid area "${i}". Options: ${s}`)}return n},t=i=>{const n=i.indexOf(":"),s=i.substring(0,n),o=i.substring(n+1);if(o==null)throw Error(`Storage key should be in the form of "area:key", but received "${i}"`);return{driverArea:s,driverKey:o,driver:r(s)}},a=i=>i+"$",y=(i,n)=>{const s={...i};return Object.entries(n).forEach(([o,g])=>{g==null?delete s[o]:s[o]=g}),s},u=(i,n)=>i??n??null,d=i=>typeof i=="object"&&!Array.isArray(i)?i:{},v=async(i,n,s)=>{const o=await i.getItem(n);return u(o,s?.fallback??s?.defaultValue)},E=async(i,n)=>{const s=a(n),o=await i.getItem(s);return d(o)},A=async(i,n,s)=>{await i.setItem(n,s??null)},f=async(i,n,s)=>{const o=a(n),g=d(await i.getItem(o));await i.setItem(o,y(g,s))},b=async(i,n,s)=>{if(await i.removeItem(n),s?.removeMeta){const o=a(n);await i.removeItem(o)}},S=async(i,n,s)=>{const o=a(n);if(s==null)await i.removeItem(o);else{const g=d(await i.getItem(o));[s].flat().forEach(p=>delete g[p]),await i.setItem(o,g)}},O=(i,n,s)=>i.watch(n,s);return{getItem:async(i,n)=>{const{driver:s,driverKey:o}=t(i);return await v(s,o,n)},getItems:async i=>{const n=new Map,s=new Map,o=[];i.forEach(p=>{let _,l;typeof p=="string"?_=p:"getValue"in p?(_=p.key,l={fallback:p.fallback}):(_=p.key,l=p.options),o.push(_);const{driverArea:c,driverKey:m}=t(_),w=n.get(c)??[];n.set(c,w.concat(m)),s.set(_,l)});const g=new Map;return await Promise.all(Array.from(n.entries()).map(async([p,_])=>{(await e[p].getItems(_)).forEach(c=>{const m=`${p}:${c.key}`,w=s.get(m),x=u(c.value,w?.fallback??w?.defaultValue);g.set(m,x)})})),o.map(p=>({key:p,value:g.get(p)}))},getMeta:async i=>{const{driver:n,driverKey:s}=t(i);return await E(n,s)},getMetas:async i=>{const n=i.map(g=>{const p=typeof g=="string"?g:g.key,{driverArea:_,driverKey:l}=t(p);return{key:p,driverArea:_,driverKey:l,driverMetaKey:a(l)}}),s=n.reduce((g,p)=>{var _;return g[_=p.driverArea]??(g[_]=[]),g[p.driverArea].push(p),g},{}),o={};return await Promise.all(Object.entries(s).map(async([g,p])=>{const _=await R.storage[g].get(p.map(l=>l.driverMetaKey));p.forEach(l=>{o[l.key]=_[l.driverMetaKey]??{}})})),n.map(g=>({key:g.key,meta:o[g.key]}))},setItem:async(i,n)=>{const{driver:s,driverKey:o}=t(i);await A(s,o,n)},setItems:async i=>{const n={};i.forEach(s=>{const{driverArea:o,driverKey:g}=t("key"in s?s.key:s.item.key);n[o]??(n[o]=[]),n[o].push({key:g,value:s.value})}),await Promise.all(Object.entries(n).map(async([s,o])=>{await r(s).setItems(o)}))},setMeta:async(i,n)=>{const{driver:s,driverKey:o}=t(i);await f(s,o,n)},setMetas:async i=>{const n={};i.forEach(s=>{const{driverArea:o,driverKey:g}=t("key"in s?s.key:s.item.key);n[o]??(n[o]=[]),n[o].push({key:g,properties:s.meta})}),await Promise.all(Object.entries(n).map(async([s,o])=>{const g=r(s),p=o.map(({key:m})=>a(m));console.log(s,p);const _=await g.getItems(p),l=Object.fromEntries(_.map(({key:m,value:w})=>[m,d(w)])),c=o.map(({key:m,properties:w})=>{const x=a(m);return{key:x,value:y(l[x]??{},w)}});await g.setItems(c)}))},removeItem:async(i,n)=>{const{driver:s,driverKey:o}=t(i);await b(s,o,n)},removeItems:async i=>{const n={};i.forEach(s=>{let o,g;typeof s=="string"?o=s:"getValue"in s?o=s.key:"item"in s?(o=s.item.key,g=s.options):(o=s.key,g=s.options);const{driverArea:p,driverKey:_}=t(o);n[p]??(n[p]=[]),n[p].push(_),g?.removeMeta&&n[p].push(a(_))}),await Promise.all(Object.entries(n).map(async([s,o])=>{await r(s).removeItems(o)}))},removeMeta:async(i,n)=>{const{driver:s,driverKey:o}=t(i);await S(s,o,n)},snapshot:async(i,n)=>{const o=await r(i).snapshot();return n?.excludeKeys?.forEach(g=>{delete o[g],delete o[a(g)]}),o},restoreSnapshot:async(i,n)=>{await r(i).restoreSnapshot(n)},watch:(i,n)=>{const{driver:s,driverKey:o}=t(i);return O(s,o,n)},unwatch(){Object.values(e).forEach(i=>{i.unwatch()})},defineItem:(i,n)=>{const{driver:s,driverKey:o}=t(i),{version:g=1,migrations:p={}}=n??{};if(g<1)throw Error("Storage item version cannot be less than 1. Initial versions should be set to 1, not 0.");const _=async()=>{const x=a(o),[{value:M},{value:I}]=await s.getItems([o,x]);if(M==null)return;const h=I?.v??1;if(h>g)throw Error(`Version downgrade detected (v${h} -> v${g}) for "${i}"`);console.debug(`[@wxt-dev/storage] Running storage migration for ${i}: v${h} -> v${g}`);const T=Array.from({length:g-h},(C,j)=>h+j+1);let k=M;for(const C of T)try{k=await p?.[C]?.(k)??k}catch(j){throw Error(`v${C} migration failed for "${i}"`,{cause:j})}await s.setItems([{key:o,value:k},{key:x,value:{...I,v:g}}]),console.debug(`[@wxt-dev/storage] Storage migration completed for ${i} v${g}`,{migratedValue:k})},l=n?.migrations==null?Promise.resolve():_().catch(x=>{console.error(`[@wxt-dev/storage] Migration failed for ${i}`,x)}),c=new Te,m=()=>n?.fallback??n?.defaultValue??null,w=()=>c.runExclusive(async()=>{const x=await s.getItem(o);if(x!=null||n?.init==null)return x;const M=await n.init();return await s.setItem(o,M),M});return l.then(w),{key:i,get defaultValue(){return m()},get fallback(){return m()},getValue:async()=>(await l,n?.init?await w():await v(s,o,n)),getMeta:async()=>(await l,await E(s,o)),setValue:async x=>(await l,await A(s,o,x)),setMeta:async x=>(await l,await f(s,o,x)),removeValue:async x=>(await l,await b(s,o,x)),removeMeta:async x=>(await l,await S(s,o,x)),watch:x=>O(s,o,(M,I)=>x(M??m(),I??m())),migrate:_}}}}function K(e){const r=()=>{if(R.runtime==null)throw Error(["'wxt/storage' must be loaded in a web extension environment",`
 - If thrown during a build, see https://github.com/wxt-dev/wxt/issues/371`,` - If thrown during tests, mock 'wxt/browser' correctly. See https://wxt.dev/guide/go-further/testing.html
`].join(`
`));if(R.storage==null)throw Error("You must add the 'storage' permission to your manifest to use 'wxt/storage'");const a=R.storage[e];if(a==null)throw Error(`"browser.storage.${e}" is undefined`);return a},t=new Set;return{getItem:async a=>(await r().get(a))[a],getItems:async a=>{const y=await r().get(a);return a.map(u=>({key:u,value:y[u]??null}))},setItem:async(a,y)=>{y==null?await r().remove(a):await r().set({[a]:y})},setItems:async a=>{const y=a.reduce((u,{key:d,value:v})=>(u[d]=v,u),{});await r().set(y)},removeItem:async a=>{await r().remove(a)},removeItems:async a=>{await r().remove(a)},snapshot:async()=>await r().get(),restoreSnapshot:async a=>{await r().set(a)},watch(a,y){const u=d=>{const v=d[a];v!=null&&(W(v.newValue,v.oldValue)||y(v.newValue??null,v.oldValue??null))};return r().onChanged.addListener(u),t.add(u),()=>{r().onChanged.removeListener(u),t.delete(u)}},unwatch(){t.forEach(a=>{r().onChanged.removeListener(a)}),t.clear()}}}var B=(e=>(e.LIGHT="light",e.DARK="dark",e.TOKYO_NIGHT="tokyo-night",e.NOCTIS_LIGHT="noctis-light",e.BESPIN="bespin",e.ANDROMEDA="andromeda",e))(B||{});U.defineItem("sync:extensionOptions",{fallback:{theme:B.LIGHT},init:()=>({theme:B.LIGHT})}),U.defineItem("local:extensionClipboard");const Pe=U.defineItem("local:extensionData"),Se=se(()=>{V.onMessage("updateFromPage",async e=>await Pe.setValue(e.data).then(()=>!0).catch(r=>(console.debug("Failed to set extensionData:",r),!1))),V.onMessage("sendToBackground",async e=>{const r=await be.tabs.query({active:!0});return await V.sendMessage("sendToContent",e.data,r[0]?.id).then(()=>!0).catch(t=>(console.debug(t),!1))})});function $e(){}function F(e,...r){}const Ce={debug:(...e)=>F(console.debug,...e),log:(...e)=>F(console.log,...e),warn:(...e)=>F(console.warn,...e),error:(...e)=>F(console.error,...e)};let G;try{G=Se.main(),G instanceof Promise&&console.warn("The background's main() function return a promise, but it must be synchronous")}catch(e){throw Ce.error("The background crashed on startup!"),e}return G}();
background;
